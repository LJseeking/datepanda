// DatePanda MVP Schema
// Based on v1 Architecture + 7 Critical Fixes

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// --------------------------------------
// Enums
// --------------------------------------

enum ResponseStatus {
  IN_PROGRESS
  SUBMITTED
  INVALID
}

enum ActionType {
  LIKE
  PASS
  UNLIKE
  UNPASS
}

enum ActionState {
  LIKE
  PASS
  NONE
}

enum VerificationStatus {
  UNVERIFIED
  PENDING
  VERIFIED
  FAILED
  EXPIRED
}

enum ConversationStatus {
  ACTIVE
  CLOSED
}

enum PolicyAction {
  GET_RECOMMENDATIONS
  GENERATE_RECOMMENDATIONS
  SUBMIT_RESPONSE
  GENERATE_PROFILE
  SEND_MESSAGE
  UPLOAD_AVATAR
  BIND_PHONE
}

enum RiskEventType {
  FAST_SUBMIT
  INCONSISTENT
  PATTERN
  ACTION_RATE
  ABUSE_GENERIC
}

enum ReportStatus {
  OPEN
  RESOLVED
  REJECTED
}

// --------------------------------------
// User & Identity
// --------------------------------------

model User {
  id        String   @id @default(cuid())
  status    String   @default("ACTIVE") // Consider enum if simple, but String allows custom
  deletedAt DateTime?
  
  cityCode  String?
  schoolId  String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  responses           Response[]
  questionnaireStates UserQuestionnaireState[]
  profiles            Profile[]
  recommendationBatches DailyRecommendationBatch[]
  recommendations     Recommendation[] @relation("Candidate")
  
  conversationMembers ConversationMember[]
  sentMessages        Message[]
  
  schoolVerifications SchoolVerification[]
  
  // Blocks & Reports
  blocksInitiated     Block[] @relation("Blocker")
  blocksReceived      Block[] @relation("Blocked")
  reportsInitiated    Report[] @relation("Reporter")
  reportsReceived     Report[] @relation("ReportTarget")

  @@index([status, deletedAt])
  @@index([cityCode, schoolId])
}

model School {
  id       String @id @default(cuid())
  cityCode String
  name     String
  
  verifications SchoolVerification[]
}

model SchoolVerification {
  id         String             @id @default(cuid())
  userId     String             @unique
  schoolId   String
  status     VerificationStatus
  method     String
  evidence   String // Json
  
  verifiedAt DateTime?
  expiresAt  DateTime?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  school School @relation(fields: [schoolId], references: [id], onDelete: Restrict)

  @@index([schoolId, status])
  @@index([status, updatedAt])
}

// --------------------------------------
// Questionnaire & Response
// --------------------------------------

model Response {
  id                    String        @id @default(cuid())
  userId                String
  questionnaireVersionId String
  status                ResponseStatus
  startedAt             DateTime      @default(now())
  submittedAt           DateTime?
  durationSec           Int?
  deviceId              String?
  clientMeta            String // Json
  invalidatedAt         DateTime?
  invalidReasonCodes    String? // Json
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Restrict)
  items ResponseItem[]
  itemOptions ResponseItemOption[]
  profile Profile?

  @@index([userId, questionnaireVersionId, createdAt])
  @@index([questionnaireVersionId, status, createdAt])
}

model ResponseItem {
  id         String @id @default(cuid())
  responseId String
  questionId String
  textValue  String?
  numericValue Int?

  response Response @relation(fields: [responseId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id], onDelete: Restrict)

  @@unique([responseId, questionId])
  @@index([responseId])
}

model ResponseItemOption {
  id         String @id @default(cuid())
  responseId String
  questionId String
  optionId   String

  response Response @relation(fields: [responseId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id], onDelete: Restrict)
  option   Option   @relation(fields: [optionId], references: [id], onDelete: Restrict)

  @@unique([responseId, questionId, optionId])
  @@index([responseId, questionId])
}

model Question {
  id String @id @default(cuid())
  code String
  // ... minimal fields
  responseItems ResponseItem[]
  responseItemOptions ResponseItemOption[]
  options Option[]
}

model Option {
  id String @id @default(cuid())
  questionId String
  question Question @relation(fields: [questionId], references: [id])
  responseItemOptions ResponseItemOption[]
}

model UserQuestionnaireState {
  id                    String @id @default(cuid())
  userId                String
  questionnaireVersionId String

  activeResponseId      String?
  submittedResponseId   String?
  submittedAt           DateTime?
  
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@unique([userId, questionnaireVersionId])
  @@index([userId, updatedAt])
}

// --------------------------------------
// Profile
// --------------------------------------

model Profile {
  id                   String @id @default(cuid())
  userId               String
  responseId           String @unique

  questionnaireVersionId String
  profileSpecVersionId String
  templateVersionId    String

  policyChecksum       String
  policySnapshot       String // Json
  profileSnapshot      String? // Json
  
  createdAt DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  response Response @relation(fields: [responseId], references: [id], onDelete: Restrict)

  @@index([userId, createdAt])
}

// --------------------------------------
// Recommendation
// --------------------------------------

model DailyRecommendationBatch {
  id            String  @id @default(cuid())
  userId        String
  dateKey       String  // YYYY-MM-DD
  algoVersion   String
  policyChecksum String
  policySnapshot String // Json
  
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  recommendations Recommendation[]

  @@unique([userId, dateKey])
  @@index([dateKey])
}

model Recommendation {
  id              String @id @default(cuid())
  batchId         String
  
  // Participants
  proposerUserId  String? // New: Batch owner / Actor (Backfill required)
  candidateUserId String
  
  score           Float
  rank            Int
  status          String
  reason          String? // Deprecated: keep for compatibility, use reasonsJson
  
  // New matching fields
  kind            String? // "MATCH_PROPOSAL"
  weekKey         String? // "YYYY-WW"
  round           String? // "THU" | "FRI"
  reasonsJson     String? // JSON array of reason strings
  metaJson        String? // Extra metadata
  
  seenAt          DateTime?
  actedAt         DateTime?
  
  createdAt DateTime @default(now())

  batch DailyRecommendationBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  candidate User @relation("Candidate", fields: [candidateUserId], references: [id], onDelete: Restrict)
  // We can add relation to Proposer too if needed, but not strictly required for logic if we just store ID.
  // proposer User @relation("Proposer", fields: [proposerUserId], references: [id]) 

  @@unique([batchId, candidateUserId])
  
  // Strong idempotency: Proposer + Kind + Week + Round
  // This replaces the previous [batchId, kind, weekKey, round] as primary check
  @@unique([proposerUserId, kind, weekKey, round])
  
  @@index([batchId, rank])
  @@index([kind, weekKey, round, status])
  @@index([kind, status, actedAt])
  // New index for filtering by proposer
  // @@index([proposerUserId, targetUserId, kind, status, actedAt]) 
  // Fixed: targetUserId is candidateUserId
  @@index([proposerUserId, candidateUserId, kind, status, actedAt])
}

// --------------------------------------
// Conversation & Message
// --------------------------------------

model Unlock {
  id      String @id @default(cuid())
  pairKey String @unique
  
  conversation Conversation?
}

model Conversation {
  id            String             @id @default(cuid())
  pairKey       String             @unique
  unlockId      String?            @unique
  status        ConversationStatus @default(ACTIVE)
  lastMessageAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  unlock   Unlock?              @relation(fields: [unlockId], references: [id], onDelete: Restrict)
  members  ConversationMember[]
  messages Message[]

  @@index([lastMessageAt])
}

model ConversationMember {
  id             String   @id @default(cuid())
  conversationId String
  userId         String
  joinedAt       DateTime @default(now())
  leftAt         DateTime?
  lastReadAt     DateTime?

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@unique([conversationId, userId])
  @@index([userId, lastReadAt])
}

model Message {
  id             String   @id @default(cuid())
  conversationId String
  senderId       String
  type           String
  content        String
  clientMsgId    String
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation(fields: [senderId], references: [id], onDelete: Restrict)

  @@unique([conversationId, clientMsgId])
  @@index([conversationId, createdAt, id])
}

// --------------------------------------
// Block & Report
// --------------------------------------

model Block {
  id            String @id @default(cuid())
  blockerId     String
  blockedUserId String
  createdAt     DateTime @default(now())

  blocker User @relation("Blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("Blocked", fields: [blockedUserId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedUserId])
  @@index([blockerId, createdAt])
  @@index([blockedUserId])
}

model Report {
  id          String @id @default(cuid())
  reporterId  String
  targetUserId String
  status      ReportStatus
  reasonCode  String
  createdAt   DateTime @default(now())

  reporter User @relation("Reporter", fields: [reporterId], references: [id], onDelete: Cascade)
  target   User @relation("ReportTarget", fields: [targetUserId], references: [id], onDelete: Cascade)

  @@index([targetUserId, status, createdAt])
}

// --------------------------------------
// Auth & OTP
// --------------------------------------

model AuthOtp {
  id         String   @id @default(cuid())
  email      String
  codeHash   String
  expiresAt  DateTime
  lastSentAt DateTime @default(now())
  attempts   Int      @default(0)
  createdAt  DateTime @default(now())

  @@index([email, expiresAt])
}

// --------------------------------------
// Notification
// --------------------------------------

model NotificationLog {
  id        String   @id @default(cuid())
  userId    String
  weekKey   String   // YYYY-WW
  round     String   // THU | FRI
  type      String   // MATCH_READY | SECOND_CHANCE
  toEmail   String
  sentAt    DateTime?
  status    String   @default("PENDING") // PENDING | SENT | FAILED
  error     String?
  proposalId String?
  retryCount Int     @default(0)
  metaJson  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Strict idempotency
  @@unique([userId, weekKey, round, type])
  @@index([weekKey, round, status])
}
